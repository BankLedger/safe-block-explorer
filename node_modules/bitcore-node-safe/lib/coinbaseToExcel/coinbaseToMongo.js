var async = require('async');
var RPCApi = require("./RPCApi");
var mongo = require("mongoskin");
var index = require('../');
var log = index.log;
var bitcore = require('bitcore-lib-dash');
var uri ="mongodb://localhost:27017/coinbase";
var options = {
    server : {
        socketOptions : {
            socketTimeoutMS : 0,
            connectionTimeout : 0
        }
    }
};
var endTimestamp = parseInt(new Date("2018/7/30").getTime() / 1000);
var endBlockHeight = 9999999;
var straBlockHeight = 807085;
function coinbaseTOMongo (){
    this.db = mongo.db(uri, options);
    this.db.bind("cbBlock");
    this.db.bind("coinbase");
    this.first=true;
}

coinbaseTOMongo.prototype.starSyncCoinbaseToMongoDB = function(myCallback) {
    var myself = this;
    async.series({
        dbHeight : function(callback) {
            myself.db.cbBlock.find({
                'id' : 1
            }).toArray(function(err, blockObj) {
                if (err) {
                    log.error("dbHeight get height for mongodb err:"+err);
                    return err;
                }
                if(blockObj && blockObj[0]){
                    blockObj=blockObj[0];
                }else{
                    blockObj={height:0};
                }
                var dbHeighRs = parseInt(blockObj.height) > 0 ? parseInt(blockObj.height):straBlockHeight;
                if(dbHeighRs >= endBlockHeight){
                    myCallback(null,heightInfo);
                }else{
                    callback(null, dbHeighRs);
                }
            })
        },
        blockHeight : function(callback) {
            myself.getInfo(function(err, blockHeight) {
                if (err) {
                    log.error("getinfo err:"+err);
                    return err;
                }
                blockHeight = blockHeight.result
                console.log("init found blockchain height is :"+blockHeight.blocks);
                callback(null, blockHeight.blocks > endBlockHeight ? endBlockHeight : blockHeight.blocks);
            })
        }
    }, function(err, heightInfo) {
        if (err) {
            log.error("synchroizedBlockAdressTxToMongoDB async.series err :"+err);
            callback(err);
        }
        var startTimestamp= new Date().getTime();
        console.log("开始同步数据区块链数据到mongoDB");
        var totalHandleBlock = parseInt(heightInfo.blockHeight) - parseInt(heightInfo.dbHeight);
        var oneStar = parseInt(totalHandleBlock / 100);
        oneStar = oneStar === 0 ? 1 : oneStar;
        if(myself.first){
            console.log("即将同步区块数量："+ totalHandleBlock +" one star equals to  "+oneStar);
        }else{
            console.log("即将同步区块数量："+ totalHandleBlock);
        }

        var handleCount = 0;
        var percent = 0;
        async.whilst(function() {
            var rs = heightInfo.blockHeight > heightInfo.dbHeight;// if true
            return rs;
        }, function(callback) {
            heightInfo.dbHeight++;
            myself.db.cbBlock.update({
                'id' : 1
            }, {
                $set : {
                    'height' : heightInfo.dbHeight
                }
            }, {
                upsert : true
            }, function(err, result) {
                if (err){
                    log.error("async.whilst error update DB "+ err);
                    callback(err);
                }
                else if(myself.first){
                    handleCount++;
                    if(Math.floor(handleCount/oneStar)>percent){
                        percent++;
                        process.stdout.write('*');
                        if(percent===100){
                            process.stdout.write('\n');
                        }
                    }
                }
            })
            myself.processBlockByHeight(heightInfo, callback); // do one block  height
        }, function(err, newHeight) {
            if (err) {
                log.error("whilst err:"+err);
                callback(err);
            }
            myself.db.cbBlock.update({
                'id' : 1
            }, {
                $set : {
                    'height' : heightInfo.blockHeight
                }
            }, {
                upsert : true
            }, function(err, result) {
                if (!err && newHeight) {
                    heightInfo.blockHeight = newHeight;
                }
            })
            console.log("total synchronized time(s):"+(new Date().getTime()-startTimestamp)/1000);
            myCallback(null,heightInfo);

        });
    });
}

coinbaseTOMongo.prototype.processBlockByHeight = function(heightInfo, callback) {
    var myself = this;
    async.waterfall([
        myself.getTxListAndBlockMessageFromHight.bind(myself, heightInfo),
        myself.processTxList.bind(myself)
    ], function(err) {
        if (err) {
            log.error("processBlockByHeight: async.waterfall error happend:"+err);
            callback(err);
        }else{
            if (heightInfo.height === heightInfo.blockHeight) {
                myself.getInfo(function(err, info) {
                    if (err) {
                        log.error("processBlockByHeight getInfo err"+err)
                        callback(err);
                    }else{
                        callback(null, info.blocks);
                    }
                })
            } else {
                callback(null);
            }
        }
    });
}

coinbaseTOMongo.prototype.getTxListAndBlockMessageFromHight = function(heightInfo,callback) {
    var self = this;
    self.getBlockObject(heightInfo.dbHeight, function(err,blockObject) {
        if (err) {
            log.error("getTxListAndBlockMessageFromHight err :"+err);
            callback(err);
        }else{
            callback(null, blockObject.result);
        }
    })
}

coinbaseTOMongo.prototype.processTxList = function(block,callback) {
    var myself = this;
    var txList = block.tx;
    var blockTimestamp = block.time;
    myself.getRawTransaction(txList[0],function(err, transaction) {
        transaction = transaction.result;
        if (err) {
            log.error("processTransaction txid:" + txid + " err:"+err);
            callback(err);
        }
        if (null == transaction) {
            log.error("processTransaction txid:" + txid + " result is empty:");
        }
        if(transaction.vin[0].coinbase && blockTimestamp <= endTimestamp){
            async.waterfall([
                    myself.processEachInput.bind(myself, transaction,block.time),
                ],
                function(err, result) {
                    if (err) {
                        log.error("processTransaction async.waterfall error happend:"+err);
                        callback(err);
                    } else {
                        callback(null);
                    }
                });
        }else{
            callback(null);
        }
    })
}

coinbaseTOMongo.prototype.processEachInput = function(transaction,blockTime,callback) {
    var myself = this;
    async.mapSeries(transaction.vout, function(vout,mycurrCallback) {
        var data = {
            value : vout.value,
            address : vout.scriptPubKey.addresses[0],
            height : transaction.height,
            time : blockTime
        }
        myself.db.coinbase.find({height:transaction.height,address:vout.scriptPubKey.addresses[0]}).toArray(function(err,result){
            if(err){
                return mycurrCallback(err)
            }
            if(!result.length ){
                myself.db.coinbase.insert(data);
            }
            mycurrCallback(null);
        })
    },function (err,prs){
        if(err){
            log.error("processEachInput async.map callback function error happend "+err);
            callback(err);
        }else{
            callback(null);
        }
    });
}

coinbaseTOMongo.prototype.getBlockObject = function(height,callback){
    getBlockHash(height,function (err,block) {
        var rpc = new RPCApi();
        rpc.getBlockObject(block.result,callback);
    })
}
function getBlockHash(height,callback){
    var rpc = new RPCApi();
    rpc.getBlockHash(height,callback);
}

coinbaseTOMongo.prototype.getRawTransaction = function(txid,callback){
    var rpc = new RPCApi();
    rpc.getRawTransaction(txid,callback);
}

coinbaseTOMongo.prototype.getInfo = function(callback){
    var rpc = new RPCApi();
    rpc.getInfo(callback);
}

module.exports = coinbaseTOMongo;